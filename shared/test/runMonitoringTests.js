const { runMonitoringTests } = require('./monitoringSystemTest');
const { runMetricsCollectorTests } = require('./metricsCollectorTest');
const { runAlertManagerTests } = require('./alertManagerTest');

async function runAllMonitoringTests() {
  console.log('üöÄ Starting Comprehensive Monitoring System Tests\n');
  console.log('=' .repeat(60));
  
  const results = {
    monitoringSystem: false,
    metricsCollector: false,
    alertManager: false
  };
  
  try {
    // Test 1: Metrics Collector
    console.log('\nüìä METRICS COLLECTOR TESTS');
    console.log('-'.repeat(40));
    results.metricsCollector = await runMetricsCollectorTests();
    
    // Test 2: Alert Manager
    console.log('\nüö® ALERT MANAGER TESTS');
    console.log('-'.repeat(40));
    results.alertManager = await runAlertManagerTests();
    
    // Test 3: Complete Monitoring System
    console.log('\nüîç MONITORING SYSTEM INTEGRATION TESTS');
    console.log('-'.repeat(40));
    results.monitoringSystem = await runMonitoringTests();
    
    // Summary
    console.log('\n' + '='.repeat(60));
    console.log('üìã TEST RESULTS SUMMARY');
    console.log('='.repeat(60));
    
    const totalTests = Object.keys(results).length;
    const passedTests = Object.values(results).filter(Boolean).length;
    
    console.log(`üìä Metrics Collector: ${results.metricsCollector ? '‚úÖ PASSED' : '‚ùå FAILED'}`);
    console.log(`üö® Alert Manager: ${results.alertManager ? '‚úÖ PASSED' : '‚ùå FAILED'}`);
    console.log(`üîç Monitoring System: ${results.monitoringSystem ? '‚úÖ PASSED' : '‚ùå FAILED'}`);
    
    console.log(`\nüìà Overall: ${passedTests}/${totalTests} tests passed`);
    
    if (passedTests === totalTests) {
      console.log('\nüéâ ALL MONITORING TESTS PASSED! üéâ');
      console.log('‚ú® The monitoring and alerting system is ready for production use.');
      return true;
    } else {
      console.log('\n‚ö†Ô∏è  Some tests failed. Please review the errors above.');
      return false;
    }
    
  } catch (error) {
    console.error('\nüí• Critical error during testing:', error.message);
    console.error(error.stack);
    return false;
  }
}

// Integration test for the complete monitoring workflow
async function runIntegrationTest() {
  console.log('\nüîÑ INTEGRATION TEST: Complete Monitoring Workflow');
  console.log('-'.repeat(50));
  
  try {
    const { MonitoringSystem } = require('../utils/MonitoringSystem');
    
    // Create monitoring system
    const system = MonitoringSystem.create({
      metrics: {
        collectionInterval: 1000,
        retentionPeriod: 1,
        maxMetricsPerComponent: 100,
        enableRealTimeCollection: false,
        components: ['frontend', 'backend', 'firebase', 'auth']
      },
      alerts: {
        enabled: true,
        checkInterval: 1000,
        defaultCooldown: 1
      }
    });
    
    console.log('‚úÖ Step 1: System created');
    
    // Start monitoring
    system.start();
    console.log('‚úÖ Step 2: Monitoring started');
    
    // Record various metrics
    await system.recordError('frontend', 'validation_error', 'medium');
    await system.recordError('frontend', 'network_error', 'high');
    await system.recordPerformance('backend', 'api_call', 1500);
    await system.recordPerformance('backend', 'database_query', 800);
    await system.recordAvailability('firebase', true);
    await system.recordAvailability('auth', false);
    
    console.log('‚úÖ Step 3: Metrics recorded');
    
    // Get dashboard data
    const dashboardData = await system.getDashboardData('last_hour');
    console.log('‚úÖ Step 4: Dashboard data retrieved');
    console.log(`   - System health: ${dashboardData.systemOverview.overallHealth.toFixed(1)}%`);
    console.log(`   - Components monitored: ${dashboardData.systemOverview.components.length}`);
    
    // Add custom alert rule
    await system.addAlertRule({
      id: 'integration_test_rule',
      name: 'Integration Test Alert',
      component: 'frontend',
      metric: 'error_count',
      condition: 'greater_than',
      threshold: 1,
      severity: 'medium',
      enabled: true,
      cooldownPeriod: 1,
      actions: [
        { type: 'log', target: 'console', enabled: true }
      ]
    });
    
    console.log('‚úÖ Step 5: Custom alert rule added');
    
    // Get monitoring statistics
    const stats = await system.getMonitoringStats();
    console.log('‚úÖ Step 6: Statistics retrieved');
    console.log(`   - Total components: ${stats.totalComponents}`);
    console.log(`   - Healthy components: ${stats.healthyComponents}`);
    console.log(`   - Active alerts: ${stats.activeAlerts}`);
    
    // Test health score
    const healthScore = await system.getHealthScore();
    console.log('‚úÖ Step 7: Health score calculated');
    console.log(`   - Health score: ${healthScore.toFixed(1)}%`);
    
    // Cleanup
    await system.cleanup();
    console.log('‚úÖ Step 8: Cleanup completed');
    
    // Stop monitoring
    system.stop();
    console.log('‚úÖ Step 9: Monitoring stopped');
    
    console.log('\nüéØ Integration test completed successfully!');
    return true;
    
  } catch (error) {
    console.error('\n‚ùå Integration test failed:', error.message);
    return false;
  }
}

// Performance test
async function runPerformanceTest() {
  console.log('\n‚ö° PERFORMANCE TEST: High Volume Metrics');
  console.log('-'.repeat(40));
  
  try {
    const { MonitoringSystem } = require('../utils/MonitoringSystem');
    
    const system = MonitoringSystem.create({
      metrics: {
        collectionInterval: 100,
        retentionPeriod: 1,
        maxMetricsPerComponent: 1000,
        enableRealTimeCollection: false,
        components: ['test_component']
      }
    });
    
    const startTime = Date.now();
    const numMetrics = 100;
    
    console.log(`üìä Recording ${numMetrics} metrics...`);
    
    // Record many metrics quickly
    for (let i = 0; i < numMetrics; i++) {
      await system.recordCustomMetric('perf_test', i, 'test_component', 'count');
      
      if (i % 20 === 0) {
        process.stdout.write('.');
      }
    }
    
    const recordTime = Date.now() - startTime;
    console.log(`\n‚úÖ Recorded ${numMetrics} metrics in ${recordTime}ms`);
    console.log(`   - Average: ${(recordTime / numMetrics).toFixed(2)}ms per metric`);
    
    // Test retrieval performance
    const retrievalStart = Date.now();
    const systemMetrics = await system.getSystemMetrics();
    const retrievalTime = Date.now() - retrievalStart;
    
    console.log(`‚úÖ Retrieved system metrics in ${retrievalTime}ms`);
    
    if (recordTime < 5000 && retrievalTime < 1000) {
      console.log('üöÄ Performance test PASSED!');
      return true;
    } else {
      console.log('‚ö†Ô∏è  Performance test completed but may be slow');
      return true; // Still pass, just note the performance
    }
    
  } catch (error) {
    console.error('\n‚ùå Performance test failed:', error.message);
    return false;
  }
}

// Main test runner
async function main() {
  const startTime = Date.now();
  
  try {
    // Run all tests
    const basicTestsPass = await runAllMonitoringTests();
    const integrationTestPass = await runIntegrationTest();
    const performanceTestPass = await runPerformanceTest();
    
    const totalTime = Date.now() - startTime;
    
    console.log('\n' + '='.repeat(60));
    console.log('üèÅ FINAL RESULTS');
    console.log('='.repeat(60));
    console.log(`‚è±Ô∏è  Total execution time: ${(totalTime / 1000).toFixed(2)}s`);
    console.log(`üß™ Basic Tests: ${basicTestsPass ? '‚úÖ PASSED' : '‚ùå FAILED'}`);
    console.log(`üîÑ Integration Test: ${integrationTestPass ? '‚úÖ PASSED' : '‚ùå FAILED'}`);
    console.log(`‚ö° Performance Test: ${performanceTestPass ? '‚úÖ PASSED' : '‚ùå FAILED'}`);
    
    const allTestsPass = basicTestsPass && integrationTestPass && performanceTestPass;
    
    if (allTestsPass) {
      console.log('\nüéä ALL TESTS PASSED! üéä');
      console.log('üöÄ The monitoring and alerting system is fully functional and ready for deployment!');
      process.exit(0);
    } else {
      console.log('\n‚ùå Some tests failed. Please review and fix the issues.');
      process.exit(1);
    }
    
  } catch (error) {
    console.error('\nüí• Test runner failed:', error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

// Export functions for use in other files
module.exports = {
  runAllMonitoringTests,
  runIntegrationTest,
  runPerformanceTest
};

// Run if this file is executed directly
if (require.main === module) {
  main();
}